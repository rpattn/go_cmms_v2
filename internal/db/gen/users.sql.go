// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, avatar_url, phone, country, created_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.AvatarUrl,
		&i.Phone,
		&i.Country,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, name, avatar_url, phone, country, created_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.AvatarUrl,
		&i.Phone,
		&i.Country,
		&i.CreatedAt,
	)
	return i, err
}

const getUserWithOrgAndRole = `-- name: GetUserWithOrgAndRole :one
WITH
  input AS (
    SELECT $1::uuid AS user_id, $2::uuid AS org_id
  ),
  u AS (
    SELECT u.id, u.email, u.name, u.avatar_url, u.phone, u.country, u.created_at
    FROM users u
    JOIN input i ON u.id = i.user_id
  ),
  o AS (
    SELECT o.id, o.slug, o.name, o.created_at
    FROM organisations o
    JOIN input i ON o.id = i.org_id
  ),
  m AS (
    SELECT om.org_id, om.user_id, om.role
    FROM org_memberships om
    JOIN o ON om.org_id = o.id
    JOIN u ON om.user_id = u.id
  )
SELECT
  u.id            AS user_id,
  u.email         AS user_email,
  u.name          AS user_name,
  u.avatar_url    AS user_avatar_url,
  u.phone         AS user_phone,
  u.country       AS user_country,
  o.id            AS org_id,
  o.slug          AS org_slug,
  o.name          AS org_name,
  m.role::text    AS role,
  (u.id IS NOT NULL)::bool AS user_exists,
  (o.id IS NOT NULL)::bool AS org_exists,
  (m.role IS NOT NULL)::bool AS role_exists
FROM input i
LEFT JOIN u ON TRUE
LEFT JOIN o ON TRUE
LEFT JOIN m ON TRUE
LIMIT 1
`

type GetUserWithOrgAndRoleParams struct {
	Column1 pgtype.UUID `db:"column_1" json:"column_1"`
	Column2 pgtype.UUID `db:"column_2" json:"column_2"`
}

type GetUserWithOrgAndRoleRow struct {
	UserID        pgtype.UUID `db:"user_id" json:"user_id"`
	UserEmail     pgtype.Text `db:"user_email" json:"user_email"`
	UserName      pgtype.Text `db:"user_name" json:"user_name"`
	UserAvatarUrl pgtype.Text `db:"user_avatar_url" json:"user_avatar_url"`
	UserPhone     pgtype.Text `db:"user_phone" json:"user_phone"`
	UserCountry   pgtype.Text `db:"user_country" json:"user_country"`
	OrgID         pgtype.UUID `db:"org_id" json:"org_id"`
	OrgSlug       pgtype.Text `db:"org_slug" json:"org_slug"`
	OrgName       pgtype.Text `db:"org_name" json:"org_name"`
	Role          string      `db:"role" json:"role"`
	UserExists    bool        `db:"user_exists" json:"user_exists"`
	OrgExists     bool        `db:"org_exists" json:"org_exists"`
	RoleExists    bool        `db:"role_exists" json:"role_exists"`
}

// params: $1 = user_id (UUID), $2 = org_id (UUID)
func (q *Queries) GetUserWithOrgAndRole(ctx context.Context, arg GetUserWithOrgAndRoleParams) (GetUserWithOrgAndRoleRow, error) {
	row := q.db.QueryRow(ctx, getUserWithOrgAndRole, arg.Column1, arg.Column2)
	var i GetUserWithOrgAndRoleRow
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserName,
		&i.UserAvatarUrl,
		&i.UserPhone,
		&i.UserCountry,
		&i.OrgID,
		&i.OrgSlug,
		&i.OrgName,
		&i.Role,
		&i.UserExists,
		&i.OrgExists,
		&i.RoleExists,
	)
	return i, err
}

const searchOrgUsers = `-- name: SearchOrgUsers :many
WITH input AS (
  SELECT
    $1::uuid   AS org_id,
    $2::jsonb AS payload
),
params AS (
  SELECT
    org_id,
    GREATEST(1, LEAST(COALESCE((payload->>'pageSize')::int, 10), 100)) AS page_size,
    GREATEST(0, COALESCE((payload->>'pageNum')::int, 0))                AS page_num,
    COALESCE(payload->'filterFields', '[]'::jsonb)                      AS filters
  FROM input
),
base AS (
  SELECT u.id, u.email, u.name, u.created_at
  FROM users u
  JOIN org_memberships m ON m.user_id = u.id
  WHERE m.org_id = (SELECT org_id FROM params)
),
filtered AS (
  SELECT
    b.id, b.email, b.name, b.created_at,
    COUNT(*) OVER () AS total_count
  FROM base b
  LEFT JOIN LATERAL (
    SELECT
      grp_idx,
      BOOL_OR(
        CASE col
          WHEN 'email' THEN
            CASE op
              WHEN 'eq' THEN b.email = val
              WHEN 'cn' THEN b.email ILIKE '%' || val || '%'
              WHEN 'sw' THEN b.email ILIKE val || '%'
              WHEN 'ew' THEN b.email ILIKE '%' || val
              ELSE b.email = val
            END
          WHEN 'name' THEN
            CASE op
              WHEN 'eq' THEN b.name = val
              WHEN 'cn' THEN b.name ILIKE '%' || val || '%'
              WHEN 'sw' THEN b.name ILIKE val || '%'
              WHEN 'ew' THEN b.name ILIKE '%' || val
              ELSE b.name = val
            END
          ELSE FALSE
        END
      ) AS group_match,
      BOOL_OR(col IS NOT NULL) AS has_recognized
    FROM (
      SELECT ROW_NUMBER() OVER () AS grp_idx, g.elem
      FROM params p,
           LATERAL jsonb_array_elements(p.filters) AS g(elem)
    ) grp
    CROSS JOIN LATERAL (
      SELECT
        CASE LOWER(COALESCE(grp.elem->>'field',''))
          WHEN 'email'     THEN 'email'
          WHEN 'name'      THEN 'name'
          WHEN 'firstname' THEN 'name'
          WHEN 'lastname'  THEN 'name'
          ELSE NULL
        END                                    AS col,
        LOWER(COALESCE(grp.elem->>'operation','eq')) AS op,
        COALESCE(grp.elem->>'value','')        AS val
      UNION ALL
      SELECT
        CASE LOWER(COALESCE(alt->>'field',''))
          WHEN 'email'     THEN 'email'
          WHEN 'name'      THEN 'name'
          WHEN 'firstname' THEN 'name'
          WHEN 'lastname'  THEN 'name'
          ELSE NULL
        END,
        LOWER(COALESCE(alt->>'operation','eq')),
        COALESCE(alt->>'value','')
      FROM jsonb_array_elements(COALESCE(grp.elem->'alternatives','[]'::jsonb)) alt
    ) c
    GROUP BY grp_idx
  ) g ON TRUE
  GROUP BY b.id, b.email, b.name, b.created_at
  HAVING COALESCE(BOOL_AND((NOT g.has_recognized) OR g.group_match), TRUE)
)
SELECT
  id::uuid       AS id,
  email::text    AS email,
  name::text     AS name,
  created_at     AS created_at,
  total_count    AS total_count
FROM filtered
ORDER BY created_at DESC
LIMIT (SELECT page_size FROM params)
OFFSET (SELECT page_size * page_num FROM params)
`

type SearchOrgUsersParams struct {
	OrgID   pgtype.UUID `db:"org_id" json:"org_id"`
	Payload []byte      `db:"payload" json:"payload"`
}

type SearchOrgUsersRow struct {
	ID         pgtype.UUID        `db:"id" json:"id"`
	Email      string             `db:"email" json:"email"`
	Name       string             `db:"name" json:"name"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"created_at"`
	TotalCount int64              `db:"total_count" json:"total_count"`
}

func (q *Queries) SearchOrgUsers(ctx context.Context, arg SearchOrgUsersParams) ([]SearchOrgUsersRow, error) {
	rows, err := q.db.Query(ctx, searchOrgUsers, arg.OrgID, arg.Payload)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchOrgUsersRow
	for rows.Next() {
		var i SearchOrgUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.CreatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE users SET
  name       = COALESCE($1, name),
  avatar_url = COALESCE($2, avatar_url),
  phone      = COALESCE($3, phone),
  country    = COALESCE($4, country)
WHERE id = $5::uuid
`

type UpdateUserProfileParams struct {
	Name      pgtype.Text `db:"name" json:"name"`
	AvatarUrl pgtype.Text `db:"avatar_url" json:"avatar_url"`
	Phone     pgtype.Text `db:"phone" json:"phone"`
	Country   pgtype.Text `db:"country" json:"country"`
	UserID    pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile,
		arg.Name,
		arg.AvatarUrl,
		arg.Phone,
		arg.Country,
		arg.UserID,
	)
	return err
}

const upsertUserByVerifiedEmail = `-- name: UpsertUserByVerifiedEmail :one
INSERT INTO users (email, name)
VALUES ($1, $2)
ON CONFLICT (email)
DO UPDATE SET name = COALESCE(users.name, EXCLUDED.name)
RETURNING id, email, name, avatar_url, phone, country, created_at
`

type UpsertUserByVerifiedEmailParams struct {
	Email string      `db:"email" json:"email"`
	Name  pgtype.Text `db:"name" json:"name"`
}

func (q *Queries) UpsertUserByVerifiedEmail(ctx context.Context, arg UpsertUserByVerifiedEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUserByVerifiedEmail, arg.Email, arg.Name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.AvatarUrl,
		&i.Phone,
		&i.Country,
		&i.CreatedAt,
	)
	return i, err
}
