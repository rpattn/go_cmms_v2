// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

type AppColumnType string

const (
	AppColumnTypeText  AppColumnType = "text"
	AppColumnTypeDate  AppColumnType = "date"
	AppColumnTypeBool  AppColumnType = "bool"
	AppColumnTypeEnum  AppColumnType = "enum"
	AppColumnTypeUuid  AppColumnType = "uuid"
	AppColumnTypeFloat AppColumnType = "float"
)

func (e *AppColumnType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AppColumnType(s)
	case string:
		*e = AppColumnType(s)
	default:
		return fmt.Errorf("unsupported scan type for AppColumnType: %T", src)
	}
	return nil
}

type NullAppColumnType struct {
	AppColumnType AppColumnType `json:"app_column_type"`
	Valid         bool          `json:"valid"` // Valid is true if AppColumnType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAppColumnType) Scan(value interface{}) error {
	if value == nil {
		ns.AppColumnType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AppColumnType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAppColumnType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AppColumnType), nil
}

type AppColumn struct {
	ID                    int64         `db:"id" json:"id"`
	TableID               int64         `db:"table_id" json:"table_id"`
	Name                  string        `db:"name" json:"name"`
	Type                  AppColumnType `db:"type" json:"type"`
	IsRequired            bool          `db:"is_required" json:"is_required"`
	IsIndexed             bool          `db:"is_indexed" json:"is_indexed"`
	EnumValues            []string      `db:"enum_values" json:"enum_values"`
	IsReference           bool          `db:"is_reference" json:"is_reference"`
	ReferenceTableID      pgtype.Int8   `db:"reference_table_id" json:"reference_table_id"`
	RequireDifferentTable bool          `db:"require_different_table" json:"require_different_table"`
}

type AppRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	TableID   int64              `db:"table_id" json:"table_id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type AppTable struct {
	ID        int64              `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type AppValuesBool struct {
	RowID    pgtype.UUID `db:"row_id" json:"row_id"`
	ColumnID int64       `db:"column_id" json:"column_id"`
	Value    pgtype.Bool `db:"value" json:"value"`
}

type AppValuesDate struct {
	RowID    pgtype.UUID `db:"row_id" json:"row_id"`
	ColumnID int64       `db:"column_id" json:"column_id"`
	Value    pgtype.Date `db:"value" json:"value"`
}

type AppValuesEnum struct {
	RowID    pgtype.UUID `db:"row_id" json:"row_id"`
	ColumnID int64       `db:"column_id" json:"column_id"`
	Value    pgtype.Text `db:"value" json:"value"`
}

type AppValuesFloat struct {
	RowID    pgtype.UUID   `db:"row_id" json:"row_id"`
	ColumnID int64         `db:"column_id" json:"column_id"`
	Value    pgtype.Float8 `db:"value" json:"value"`
}

type AppValuesText struct {
	RowID    pgtype.UUID `db:"row_id" json:"row_id"`
	ColumnID int64       `db:"column_id" json:"column_id"`
	Value    pgtype.Text `db:"value" json:"value"`
}

type AppValuesUuid struct {
	RowID    pgtype.UUID `db:"row_id" json:"row_id"`
	ColumnID int64       `db:"column_id" json:"column_id"`
	Value    pgtype.UUID `db:"value" json:"value"`
}

type Identity struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	UserID   pgtype.UUID `db:"user_id" json:"user_id"`
	Provider string      `db:"provider" json:"provider"`
	Subject  string      `db:"subject" json:"subject"`
}

type IdpGroupRoleMapping struct {
	OrgID      pgtype.UUID `db:"org_id" json:"org_id"`
	Provider   string      `db:"provider" json:"provider"`
	IdpGroupID string      `db:"idp_group_id" json:"idp_group_id"`
	RoleName   interface{} `db:"role_name" json:"role_name"`
}

type LocalCredential struct {
	UserID             pgtype.UUID        `db:"user_id" json:"user_id"`
	Username           string             `db:"username" json:"username"`
	PasswordHash       string             `db:"password_hash" json:"password_hash"`
	CreatedAt          pgtype.Timestamptz `db:"created_at" json:"created_at"`
	LastPasswordChange pgtype.Timestamptz `db:"last_password_change" json:"last_password_change"`
}

type LoginAttempt struct {
	ID       int64              `db:"id" json:"id"`
	Username string             `db:"username" json:"username"`
	Ip       netip.Addr         `db:"ip" json:"ip"`
	Ts       pgtype.Timestamptz `db:"ts" json:"ts"`
	Success  bool               `db:"success" json:"success"`
}

type OrgInvite struct {
	TokenHash string             `db:"token_hash" json:"token_hash"`
	OrgID     pgtype.UUID        `db:"org_id" json:"org_id"`
	Email     string             `db:"email" json:"email"`
	Role      interface{}        `db:"role" json:"role"`
	InviterID pgtype.UUID        `db:"inviter_id" json:"inviter_id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	UsedAt    pgtype.Timestamptz `db:"used_at" json:"used_at"`
}

type OrgMembership struct {
	OrgID  pgtype.UUID `db:"org_id" json:"org_id"`
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
	Role   interface{} `db:"role" json:"role"`
}

type Organisation struct {
	ID         pgtype.UUID        `db:"id" json:"id"`
	Slug       string             `db:"slug" json:"slug"`
	Name       string             `db:"name" json:"name"`
	MsTenantID pgtype.Text        `db:"ms_tenant_id" json:"ms_tenant_id"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type PasswordReset struct {
	Token     string             `db:"token" json:"token"`
	UserID    pgtype.UUID        `db:"user_id" json:"user_id"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	UsedAt    pgtype.Timestamptz `db:"used_at" json:"used_at"`
}

type SeedCfg struct {
	Email    pgtype.Text `db:"email" json:"email"`
	Name     pgtype.Text `db:"name" json:"name"`
	Username pgtype.Text `db:"username" json:"username"`
	Phc      pgtype.Text `db:"phc" json:"phc"`
	OrgSlug  pgtype.Text `db:"org_slug" json:"org_slug"`
	OrgName  pgtype.Text `db:"org_name" json:"org_name"`
	MsTenant pgtype.Text `db:"ms_tenant" json:"ms_tenant"`
}

type SeedOrg struct {
	Slug       pgtype.Text `db:"slug" json:"slug"`
	Name       pgtype.Text `db:"name" json:"name"`
	MsTenantID pgtype.Text `db:"ms_tenant_id" json:"ms_tenant_id"`
}

type User struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	Email     string             `db:"email" json:"email"`
	Name      pgtype.Text        `db:"name" json:"name"`
	AvatarUrl pgtype.Text        `db:"avatar_url" json:"avatar_url"`
	Phone     pgtype.Text        `db:"phone" json:"phone"`
	Country   pgtype.Text        `db:"country" json:"country"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type UserTotp struct {
	UserID    pgtype.UUID        `db:"user_id" json:"user_id"`
	Secret    string             `db:"secret" json:"secret"`
	Issuer    string             `db:"issuer" json:"issuer"`
	Label     string             `db:"label" json:"label"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type WorkOrderCounter struct {
	OrganisationID pgtype.UUID `db:"organisation_id" json:"organisation_id"`
	Year           int32       `db:"year" json:"year"`
	NextSeq        int32       `db:"next_seq" json:"next_seq"`
}
