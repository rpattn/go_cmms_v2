// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_tables.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserTableColumn = `-- name: AddUserTableColumn :one
WITH params AS (
  SELECT
    $1::uuid     AS org_id,
    $2::text AS table_name,
    $3::text AS column_name,
    $4::text   AS col_type,
    $5::boolean AS is_required,
    $6::boolean  AS is_indexed,
    $7::jsonb   AS enum_values,
    $8::boolean AS is_reference,
    $9::text AS reference_table,
    $10::boolean AS require_different_table
),
table_id AS (
  SELECT id
  FROM app.tables t
  WHERE (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
    AND (t.org_id = (SELECT org_id FROM params) OR t.org_id IS NULL)
  ORDER BY CASE WHEN t.org_id = (SELECT org_id FROM params) THEN 0 ELSE 1 END
  LIMIT 1
),
cname AS (
  SELECT trim(both '_' from regexp_replace(lower((SELECT column_name FROM params)), '[^a-z0-9_]+', '_', 'g')) AS name
),
refname AS (
  SELECT NULLIF((SELECT reference_table FROM params), '') AS ref
),
ref_table_id AS (
  SELECT (
    SELECT id
    FROM app.tables t
    WHERE (t.slug = lower((SELECT ref FROM refname))
           OR lower(t.name) = lower((SELECT ref FROM refname)))
      AND (t.org_id = (SELECT org_id FROM params) OR t.org_id IS NULL)
    ORDER BY CASE WHEN t.org_id = (SELECT org_id FROM params) THEN 0 ELSE 1 END
    LIMIT 1
  ) AS id
),
ins AS (
  INSERT INTO app.columns (
    table_id, name, type, is_required, is_indexed, enum_values, is_reference, reference_table_id, require_different_table
  )
  SELECT 
    (SELECT id FROM table_id),
    (SELECT name FROM cname),
    (SELECT col_type::app.column_type FROM params),
    (SELECT is_required FROM params),
    (SELECT is_indexed FROM params),
    (
      CASE WHEN (SELECT col_type FROM params) = 'enum' THEN
        ARRAY(SELECT jsonb_array_elements_text((SELECT enum_values FROM params)))
      ELSE NULL::text[] END
    ),
    (SELECT is_reference FROM params),
    (SELECT id FROM ref_table_id),
    (SELECT require_different_table FROM params)
  ON CONFLICT (table_id, name) DO NOTHING
  RETURNING id, table_id, name, type::text AS type, is_required, is_indexed, enum_values, is_reference, reference_table_id, require_different_table
),
_ensure AS (
  SELECT CASE WHEN (SELECT is_indexed FROM params) THEN app.ensure_index(id) END FROM ins
)
SELECT true AS created,
       id, table_id, name, type, is_required, is_indexed, to_jsonb(enum_values) AS enum_values,
       is_reference, reference_table_id, require_different_table
FROM ins
UNION ALL
SELECT false AS created,
       c.id, c.table_id, c.name, c.type::text AS type, c.is_required, c.is_indexed, to_jsonb(c.enum_values) AS enum_values,
       c.is_reference, c.reference_table_id, c.require_different_table
FROM app.columns c, cname
WHERE c.table_id = (SELECT id FROM table_id) AND c.name = (SELECT name FROM cname)
LIMIT 1
`

type AddUserTableColumnParams struct {
	OrgID                 pgtype.UUID `db:"org_id" json:"org_id"`
	TableName             string      `db:"table_name" json:"table_name"`
	ColumnName            string      `db:"column_name" json:"column_name"`
	ColType               string      `db:"col_type" json:"col_type"`
	IsRequired            bool        `db:"is_required" json:"is_required"`
	IsIndexed             bool        `db:"is_indexed" json:"is_indexed"`
	EnumValues            []byte      `db:"enum_values" json:"enum_values"`
	IsReference           bool        `db:"is_reference" json:"is_reference"`
	ReferenceTable        string      `db:"reference_table" json:"reference_table"`
	RequireDifferentTable bool        `db:"require_different_table" json:"require_different_table"`
}

type AddUserTableColumnRow struct {
	Created               bool        `db:"created" json:"created"`
	ID                    int64       `db:"id" json:"id"`
	TableID               int64       `db:"table_id" json:"table_id"`
	Name                  string      `db:"name" json:"name"`
	Type                  string      `db:"type" json:"type"`
	IsRequired            bool        `db:"is_required" json:"is_required"`
	IsIndexed             bool        `db:"is_indexed" json:"is_indexed"`
	EnumValues            []byte      `db:"enum_values" json:"enum_values"`
	IsReference           bool        `db:"is_reference" json:"is_reference"`
	ReferenceTableID      pgtype.Int8 `db:"reference_table_id" json:"reference_table_id"`
	RequireDifferentTable bool        `db:"require_different_table" json:"require_different_table"`
}

func (q *Queries) AddUserTableColumn(ctx context.Context, arg AddUserTableColumnParams) (AddUserTableColumnRow, error) {
	row := q.db.QueryRow(ctx, addUserTableColumn,
		arg.OrgID,
		arg.TableName,
		arg.ColumnName,
		arg.ColType,
		arg.IsRequired,
		arg.IsIndexed,
		arg.EnumValues,
		arg.IsReference,
		arg.ReferenceTable,
		arg.RequireDifferentTable,
	)
	var i AddUserTableColumnRow
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.TableID,
		&i.Name,
		&i.Type,
		&i.IsRequired,
		&i.IsIndexed,
		&i.EnumValues,
		&i.IsReference,
		&i.ReferenceTableID,
		&i.RequireDifferentTable,
	)
	return i, err
}

const createUserTable = `-- name: CreateUserTable :one
WITH s AS (
  SELECT trim(both '-' from regexp_replace(lower($1::text), '[^a-z0-9]+', '-', 'g')) AS slug
), ins AS (
  INSERT INTO app.tables (org_id, name, slug)
  SELECT $2::uuid, $1::text, s.slug FROM s
  ON CONFLICT (org_id, slug) DO NOTHING
  RETURNING id, name, slug, created_at
)
SELECT true AS created, id, name, slug, created_at FROM ins
UNION ALL
SELECT false AS created, t.id, t.name, t.slug, t.created_at
FROM app.tables t
JOIN s ON s.slug = t.slug
WHERE t.org_id = $2::uuid
LIMIT 1
`

type CreateUserTableParams struct {
	Name  string      `db:"name" json:"name"`
	OrgID pgtype.UUID `db:"org_id" json:"org_id"`
}

type CreateUserTableRow struct {
	Created   bool               `db:"created" json:"created"`
	ID        int64              `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateUserTable(ctx context.Context, arg CreateUserTableParams) (CreateUserTableRow, error) {
	row := q.db.QueryRow(ctx, createUserTable, arg.Name, arg.OrgID)
	var i CreateUserTableRow
	err := row.Scan(
		&i.Created,
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUserTable = `-- name: DeleteUserTable :one
WITH params AS (
  SELECT
    $1::uuid     AS org_id,
    $2::text AS table_name
),
target AS (
  SELECT id, name, slug, created_at
  FROM app.tables t
  WHERE t.org_id = (SELECT org_id FROM params)
    AND (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
  LIMIT 1
),
del AS (
  DELETE FROM app.tables t
  WHERE t.id IN (SELECT id FROM target)
    AND t.org_id = (SELECT org_id FROM params)
  RETURNING id
)
SELECT (SELECT COUNT(*) > 0 FROM del) AS deleted,
       (SELECT id FROM target) AS id,
       (SELECT name FROM target) AS name,
       (SELECT slug FROM target) AS slug,
       (SELECT created_at FROM target) AS created_at
`

type DeleteUserTableParams struct {
	OrgID     pgtype.UUID `db:"org_id" json:"org_id"`
	TableName string      `db:"table_name" json:"table_name"`
}

type DeleteUserTableRow struct {
	Deleted   bool               `db:"deleted" json:"deleted"`
	ID        int64              `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) DeleteUserTable(ctx context.Context, arg DeleteUserTableParams) (DeleteUserTableRow, error) {
	row := q.db.QueryRow(ctx, deleteUserTable, arg.OrgID, arg.TableName)
	var i DeleteUserTableRow
	err := row.Scan(
		&i.Deleted,
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUserTableRow = `-- name: DeleteUserTableRow :one
WITH params AS (
  SELECT
    $1::uuid      AS org_id,
    $2::text  AS table_name,
    $3::uuid      AS row_id
),
table_id AS (
  SELECT id
  FROM app.tables t
  WHERE (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
    AND t.org_id = (SELECT org_id FROM params)
  LIMIT 1
),
target AS (
  SELECT r.id
  FROM app.rows r
  WHERE r.id = (SELECT row_id FROM params)
    AND r.table_id = (SELECT id FROM table_id)
),
del AS (
  DELETE FROM app.rows r
  WHERE r.id IN (SELECT id FROM target)
  RETURNING r.id
)
SELECT (SELECT COUNT(*) > 0 FROM del) AS deleted,
       (SELECT id FROM target) AS row_id
`

type DeleteUserTableRowParams struct {
	OrgID     pgtype.UUID `db:"org_id" json:"org_id"`
	TableName string      `db:"table_name" json:"table_name"`
	RowID     pgtype.UUID `db:"row_id" json:"row_id"`
}

type DeleteUserTableRowRow struct {
	Deleted bool        `db:"deleted" json:"deleted"`
	RowID   pgtype.UUID `db:"row_id" json:"row_id"`
}

func (q *Queries) DeleteUserTableRow(ctx context.Context, arg DeleteUserTableRowParams) (DeleteUserTableRowRow, error) {
	row := q.db.QueryRow(ctx, deleteUserTableRow, arg.OrgID, arg.TableName, arg.RowID)
	var i DeleteUserTableRowRow
	err := row.Scan(&i.Deleted, &i.RowID)
	return i, err
}

const getRowData = `-- name: GetRowData :one
WITH r AS (
  SELECT r.id
  FROM app.rows r
  JOIN app.tables t ON t.id = r.table_id
  WHERE r.id = $1::uuid
    AND t.org_id = $2::uuid
)
SELECT EXISTS(SELECT 1 FROM r) AS found,
       CASE WHEN EXISTS(SELECT 1 FROM r)
            THEN app.row_to_json($1::uuid)
            ELSE NULL
       END AS data
`

type GetRowDataParams struct {
	RowID pgtype.UUID `db:"row_id" json:"row_id"`
	OrgID pgtype.UUID `db:"org_id" json:"org_id"`
}

type GetRowDataRow struct {
	Found bool        `db:"found" json:"found"`
	Data  interface{} `db:"data" json:"data"`
}

func (q *Queries) GetRowData(ctx context.Context, arg GetRowDataParams) (GetRowDataRow, error) {
	row := q.db.QueryRow(ctx, getRowData, arg.RowID, arg.OrgID)
	var i GetRowDataRow
	err := row.Scan(&i.Found, &i.Data)
	return i, err
}

const getUserTableSchema = `-- name: GetUserTableSchema :many
WITH params AS (
  SELECT
    $1::text AS table_name,
    $2::uuid     AS org_id
),
table_id AS (
  SELECT id
  FROM app.tables t
  WHERE (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
    AND (t.org_id = (SELECT org_id FROM params) OR t.org_id IS NULL)
  ORDER BY CASE WHEN t.org_id = (SELECT org_id FROM params) THEN 0 ELSE 1 END
  LIMIT 1
)
SELECT 
  c.id,
  c.name,
  c.type::text AS type,
  c.is_required,
  c.is_indexed,
  to_jsonb(c.enum_values) AS enum_values,
  c.is_reference,
  c.reference_table_id,
  c.require_different_table
FROM app.columns c
WHERE c.table_id = (SELECT id FROM table_id)
ORDER BY c.id ASC
`

type GetUserTableSchemaParams struct {
	TableName string      `db:"table_name" json:"table_name"`
	OrgID     pgtype.UUID `db:"org_id" json:"org_id"`
}

type GetUserTableSchemaRow struct {
	ID                    int64       `db:"id" json:"id"`
	Name                  string      `db:"name" json:"name"`
	Type                  string      `db:"type" json:"type"`
	IsRequired            bool        `db:"is_required" json:"is_required"`
	IsIndexed             bool        `db:"is_indexed" json:"is_indexed"`
	EnumValues            []byte      `db:"enum_values" json:"enum_values"`
	IsReference           bool        `db:"is_reference" json:"is_reference"`
	ReferenceTableID      pgtype.Int8 `db:"reference_table_id" json:"reference_table_id"`
	RequireDifferentTable bool        `db:"require_different_table" json:"require_different_table"`
}

func (q *Queries) GetUserTableSchema(ctx context.Context, arg GetUserTableSchemaParams) ([]GetUserTableSchemaRow, error) {
	rows, err := q.db.Query(ctx, getUserTableSchema, arg.TableName, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTableSchemaRow
	for rows.Next() {
		var i GetUserTableSchemaRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.IsRequired,
			&i.IsIndexed,
			&i.EnumValues,
			&i.IsReference,
			&i.ReferenceTableID,
			&i.RequireDifferentTable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserTableRow = `-- name: InsertUserTableRow :one
WITH params AS (
  SELECT
    $1::uuid     AS org_id,
    $2::text AS table_name,
    $3::jsonb    AS values
),
table_id AS (
  SELECT id
  FROM app.tables t
  WHERE (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
    AND (t.org_id = (SELECT org_id FROM params) OR t.org_id IS NULL)
  ORDER BY CASE WHEN t.org_id = (SELECT org_id FROM params) THEN 0 ELSE 1 END
  LIMIT 1
),
ins AS (
  SELECT app.insert_row((SELECT id FROM table_id), (SELECT values FROM params)) AS row_id
)
SELECT i.row_id,
       app.row_to_json(i.row_id) AS data
FROM ins i
`

type InsertUserTableRowParams struct {
	OrgID     pgtype.UUID `db:"org_id" json:"org_id"`
	TableName string      `db:"table_name" json:"table_name"`
	Values    []byte      `db:"values" json:"values"`
}

type InsertUserTableRowRow struct {
	RowID pgtype.UUID `db:"row_id" json:"row_id"`
	Data  []byte      `db:"data" json:"data"`
}

func (q *Queries) InsertUserTableRow(ctx context.Context, arg InsertUserTableRowParams) (InsertUserTableRowRow, error) {
	row := q.db.QueryRow(ctx, insertUserTableRow, arg.OrgID, arg.TableName, arg.Values)
	var i InsertUserTableRowRow
	err := row.Scan(&i.RowID, &i.Data)
	return i, err
}

const listIndexedColumns = `-- name: ListIndexedColumns :many
SELECT 
  t.id          AS table_id,
  t.slug        AS table_slug,
  t.name        AS table_name,
  c.id          AS column_id,
  c.name        AS column_name,
  c.type::text  AS column_type
FROM app.tables t
JOIN app.columns c ON c.table_id = t.id
WHERE t.org_id = $1::uuid
  AND c.is_indexed
  AND c.type IN ('text','enum')
ORDER BY t.name ASC, c.name ASC
`

type ListIndexedColumnsRow struct {
	TableID    int64  `db:"table_id" json:"table_id"`
	TableSlug  string `db:"table_slug" json:"table_slug"`
	TableName  string `db:"table_name" json:"table_name"`
	ColumnID   int64  `db:"column_id" json:"column_id"`
	ColumnName string `db:"column_name" json:"column_name"`
	ColumnType string `db:"column_type" json:"column_type"`
}

func (q *Queries) ListIndexedColumns(ctx context.Context, orgID pgtype.UUID) ([]ListIndexedColumnsRow, error) {
	rows, err := q.db.Query(ctx, listIndexedColumns, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIndexedColumnsRow
	for rows.Next() {
		var i ListIndexedColumnsRow
		if err := rows.Scan(
			&i.TableID,
			&i.TableSlug,
			&i.TableName,
			&i.ColumnID,
			&i.ColumnName,
			&i.ColumnType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTables = `-- name: ListUserTables :many
SELECT id, name, slug, created_at
FROM app.tables
WHERE org_id = $1::uuid
ORDER BY created_at DESC, id DESC
`

type ListUserTablesRow struct {
	ID        int64              `db:"id" json:"id"`
	Name      string             `db:"name" json:"name"`
	Slug      string             `db:"slug" json:"slug"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) ListUserTables(ctx context.Context, orgID pgtype.UUID) ([]ListUserTablesRow, error) {
	rows, err := q.db.Query(ctx, listUserTables, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserTablesRow
	for rows.Next() {
		var i ListUserTablesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lookupIndexedRows = `-- name: LookupIndexedRows :many
WITH params AS (
  SELECT
    $1::uuid      AS org_id,
    $2::text  AS table_name,
    NULLIF($3::text,'')       AS field,
    NULLIF($4::text,'') AS q,
    GREATEST(1, LEAST(COALESCE($5::int, 20), 100)) AS lim
),
table_id AS (
  SELECT id
  FROM app.tables t
  WHERE (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
    AND (t.org_id = (SELECT org_id FROM params) OR t.org_id IS NULL)
  ORDER BY CASE WHEN t.org_id = (SELECT org_id FROM params) THEN 0 ELSE 1 END
  LIMIT 1
),
label_col AS (
  SELECT c.id, c.name, c.type::text AS type
  FROM app.columns c
  WHERE c.table_id = (SELECT id FROM table_id)
    AND c.type IN ('text','enum')
    AND ((SELECT field FROM params) IS NULL OR lower(c.name) = lower((SELECT field FROM params)))
  ORDER BY 
    CASE WHEN lower(c.name) = 'title' THEN 0 ELSE 1 END,
    CASE WHEN c.is_indexed THEN 0 ELSE 1 END,
    c.id
  LIMIT 1
),
results AS (
  SELECT r.id AS row_id, vt.value AS label
  FROM app.values_text vt
  JOIN app.rows r ON r.id = vt.row_id
  WHERE (SELECT type FROM label_col) = 'text'
    AND vt.column_id = (SELECT id FROM label_col)
    AND r.table_id = (SELECT id FROM table_id)
    AND ((SELECT q FROM params) IS NULL OR vt.value ILIKE '%' || (SELECT q FROM params) || '%')
  UNION ALL
  SELECT r.id AS row_id, ve.value AS label
  FROM app.values_enum ve
  JOIN app.rows r ON r.id = ve.row_id
  WHERE (SELECT type FROM label_col) = 'enum'
    AND ve.column_id = (SELECT id FROM label_col)
    AND r.table_id = (SELECT id FROM table_id)
    AND ((SELECT q FROM params) IS NULL OR ve.value ILIKE '%' || (SELECT q FROM params) || '%')
)
SELECT row_id, label
FROM results
ORDER BY label ASC NULLS LAST
LIMIT (SELECT lim FROM params)
`

type LookupIndexedRowsParams struct {
	OrgID      pgtype.UUID `db:"org_id" json:"org_id"`
	TableName  string      `db:"table_name" json:"table_name"`
	Field      string      `db:"field" json:"field"`
	Q          string      `db:"q" json:"q"`
	LimitCount int32       `db:"limit_count" json:"limit_count"`
}

type LookupIndexedRowsRow struct {
	RowID pgtype.UUID `db:"row_id" json:"row_id"`
	Label pgtype.Text `db:"label" json:"label"`
}

func (q *Queries) LookupIndexedRows(ctx context.Context, arg LookupIndexedRowsParams) ([]LookupIndexedRowsRow, error) {
	rows, err := q.db.Query(ctx, lookupIndexedRows,
		arg.OrgID,
		arg.TableName,
		arg.Field,
		arg.Q,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LookupIndexedRowsRow
	for rows.Next() {
		var i LookupIndexedRowsRow
		if err := rows.Scan(&i.RowID, &i.Label); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserTableColumn = `-- name: RemoveUserTableColumn :one
WITH params AS (
  SELECT
    $1::uuid     AS org_id,
    $2::text AS table_name,
    $3::text AS column_name
),
table_id AS (
  SELECT id
  FROM app.tables t
  WHERE (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
    AND (t.org_id = (SELECT org_id FROM params) OR t.org_id IS NULL)
  ORDER BY CASE WHEN t.org_id = (SELECT org_id FROM params) THEN 0 ELSE 1 END
  LIMIT 1
),
cname AS (
  SELECT trim(both '_' from regexp_replace(lower((SELECT column_name FROM params)), '[^a-z0-9_]+', '_', 'g')) AS name
),
target AS (
  SELECT c.id, c.table_id, c.name, c.type::text AS type, c.is_required, c.is_indexed,
         c.enum_values, c.is_reference, c.reference_table_id, c.require_different_table
  FROM app.columns c
  WHERE c.table_id = (SELECT id FROM table_id) AND c.name = (SELECT name FROM cname)
  LIMIT 1
),
del AS (
  DELETE FROM app.columns c
  WHERE c.id IN (SELECT id FROM target)
  RETURNING c.id
)
SELECT 
  (SELECT COUNT(*) > 0 FROM del) AS deleted,
  (SELECT id FROM target) AS id,
  (SELECT table_id FROM target) AS table_id,
  (SELECT name FROM target) AS name,
  (SELECT type FROM target) AS type,
  (SELECT is_required FROM target) AS is_required,
  (SELECT is_indexed FROM target) AS is_indexed,
  to_jsonb((SELECT enum_values FROM target)) AS enum_values,
  (SELECT is_reference FROM target) AS is_reference,
  (SELECT reference_table_id FROM target) AS reference_table_id,
  (SELECT require_different_table FROM target) AS require_different_table
`

type RemoveUserTableColumnParams struct {
	OrgID      pgtype.UUID `db:"org_id" json:"org_id"`
	TableName  string      `db:"table_name" json:"table_name"`
	ColumnName string      `db:"column_name" json:"column_name"`
}

type RemoveUserTableColumnRow struct {
	Deleted               bool        `db:"deleted" json:"deleted"`
	ID                    int64       `db:"id" json:"id"`
	TableID               int64       `db:"table_id" json:"table_id"`
	Name                  string      `db:"name" json:"name"`
	Type                  string      `db:"type" json:"type"`
	IsRequired            bool        `db:"is_required" json:"is_required"`
	IsIndexed             bool        `db:"is_indexed" json:"is_indexed"`
	EnumValues            []byte      `db:"enum_values" json:"enum_values"`
	IsReference           bool        `db:"is_reference" json:"is_reference"`
	ReferenceTableID      pgtype.Int8 `db:"reference_table_id" json:"reference_table_id"`
	RequireDifferentTable bool        `db:"require_different_table" json:"require_different_table"`
}

func (q *Queries) RemoveUserTableColumn(ctx context.Context, arg RemoveUserTableColumnParams) (RemoveUserTableColumnRow, error) {
	row := q.db.QueryRow(ctx, removeUserTableColumn, arg.OrgID, arg.TableName, arg.ColumnName)
	var i RemoveUserTableColumnRow
	err := row.Scan(
		&i.Deleted,
		&i.ID,
		&i.TableID,
		&i.Name,
		&i.Type,
		&i.IsRequired,
		&i.IsIndexed,
		&i.EnumValues,
		&i.IsReference,
		&i.ReferenceTableID,
		&i.RequireDifferentTable,
	)
	return i, err
}

const searchUserTable = `-- name: SearchUserTable :many
WITH params AS (
  SELECT
    $1::text AS table_name,
    $2::jsonb   AS p,
    $3::uuid     AS org_id
),
table_id AS (
  SELECT id
  FROM app.tables t
  WHERE (t.slug = lower((SELECT table_name FROM params))
         OR lower(t.name) = lower((SELECT table_name FROM params)))
    AND t.org_id = (SELECT org_id FROM params)
  ORDER BY CASE WHEN t.org_id = (SELECT org_id FROM params) THEN 0 ELSE 1 END
  LIMIT 1
),
page AS (
  SELECT
    GREATEST(0, COALESCE((p->>'pageNum')::int, 0))                AS page_num,
    GREATEST(1, LEAST(COALESCE((p->>'pageSize')::int, 10), 100)) AS page_size
  FROM params
),
ff AS (
  SELECT jsonb_array_elements(p->'filterFields') AS f
  FROM params
  WHERE (p ? 'filterFields') AND jsonb_typeof(p->'filterFields') = 'array'
),
filtered AS (
  SELECT 
    b.id,
    b.created_at,
    app.row_to_json(b.id) as data,
    COUNT(*) OVER() AS total_count
  FROM app.rows b
  WHERE b.table_id = (SELECT id FROM table_id)
  AND (
    NOT EXISTS (SELECT 1 FROM ff) OR
    EXISTS (
      SELECT 1
      FROM ff
      LEFT JOIN app.columns c ON c.table_id = (SELECT id FROM table_id)
        AND lower(c.name) = lower(f->>'field')
      WHERE 
        CASE
          WHEN c.type = 'text' THEN EXISTS (
            SELECT 1 FROM app.values_text vt
            WHERE vt.row_id = b.id AND vt.column_id = c.id AND (
              CASE COALESCE(f->>'operation','eq')
                WHEN 'eq' THEN vt.value = (f->>'value')
                WHEN 'cn' THEN vt.value ILIKE '%' || (f->>'value') || '%'
                WHEN 'in' THEN vt.value = ANY(ARRAY(SELECT jsonb_array_elements_text(f->'values')))
                ELSE TRUE
              END
            )
          )
          WHEN c.type = 'enum' THEN EXISTS (
            SELECT 1 FROM app.values_enum ve
            WHERE ve.row_id = b.id AND ve.column_id = c.id AND (
              CASE COALESCE(f->>'operation','eq')
                WHEN 'eq' THEN ve.value = (f->>'value')
                WHEN 'in' THEN ve.value = ANY(ARRAY(SELECT jsonb_array_elements_text(f->'values')))
                ELSE TRUE
              END
            )
          )
          WHEN c.type = 'bool' THEN EXISTS (
            SELECT 1 FROM app.values_bool vb
            WHERE vb.row_id = b.id AND vb.column_id = c.id 
            AND vb.value IS NOT DISTINCT FROM ((f->>'value')::boolean)
          )
          ELSE TRUE
        END
    )
  )
)
SELECT 
  f.id AS row_id,
  f.data,
  f.total_count
FROM filtered f
ORDER BY f.created_at DESC
LIMIT (SELECT page_size FROM page)
OFFSET (SELECT page_size * page_num FROM page)
`

type SearchUserTableParams struct {
	TableName string      `db:"table_name" json:"table_name"`
	Payload   []byte      `db:"payload" json:"payload"`
	OrgID     pgtype.UUID `db:"org_id" json:"org_id"`
}

type SearchUserTableRow struct {
	RowID      pgtype.UUID `db:"row_id" json:"row_id"`
	Data       []byte      `db:"data" json:"data"`
	TotalCount int64       `db:"total_count" json:"total_count"`
}

func (q *Queries) SearchUserTable(ctx context.Context, arg SearchUserTableParams) ([]SearchUserTableRow, error) {
	rows, err := q.db.Query(ctx, searchUserTable, arg.TableName, arg.Payload, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUserTableRow
	for rows.Next() {
		var i SearchUserTableRow
		if err := rows.Scan(&i.RowID, &i.Data, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
