// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: totp.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTOTPSecret = `-- name: GetTOTPSecret :one
SELECT secret
FROM user_totp
WHERE user_id = $1
`

func (q *Queries) GetTOTPSecret(ctx context.Context, userID pgtype.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getTOTPSecret, userID)
	var secret string
	err := row.Scan(&secret)
	return secret, err
}

const setTOTPSecret = `-- name: SetTOTPSecret :exec
INSERT INTO user_totp (user_id, secret, issuer, label)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id)
DO UPDATE SET secret = EXCLUDED.secret,
              issuer = EXCLUDED.issuer,
              label  = EXCLUDED.label
`

type SetTOTPSecretParams struct {
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
	Secret string      `db:"secret" json:"secret"`
	Issuer string      `db:"issuer" json:"issuer"`
	Label  string      `db:"label" json:"label"`
}

func (q *Queries) SetTOTPSecret(ctx context.Context, arg SetTOTPSecretParams) error {
	_, err := q.db.Exec(ctx, setTOTPSecret,
		arg.UserID,
		arg.Secret,
		arg.Issuer,
		arg.Label,
	)
	return err
}

const userHasTOTP = `-- name: UserHasTOTP :one
SELECT EXISTS (
  SELECT 1 FROM user_totp WHERE user_id = $1
) AS has_totp
`

func (q *Queries) UserHasTOTP(ctx context.Context, userID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, userHasTOTP, userID)
	var has_totp bool
	err := row.Scan(&has_totp)
	return has_totp, err
}
